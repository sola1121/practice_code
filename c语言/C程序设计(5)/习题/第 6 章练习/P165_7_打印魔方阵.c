#include "stdio.h"

/*
    魔方阵是指一个方阵, 它的每一行, 每一列和对角线之和均相等

    8 1 6
    3 5 7
    4 9 2

    生成 1~n**2 魔方阵
    规律:
    1. 将1放在第1行中间一列
    2. 从2开始直到n*n止, 各数依次按此规则存放: 每一个数存放的行比前一个数的行数减1, 列数加1.
       例如: 上面的三阶魔方阵, 5在4的上一行后一列
    3. 如果上一数的行数为1, 则下一个数的行数为n(指最下一行).
       例如: 1在第1行, 则2应放在最下一行, 列数同样加一
    4. 当上一个数的列数为n时, 下一个数的列数应为1, 行数减1.
       例如: 2在第3行最后一列, 则3应放在第2行第1列
    5. 如果按上面规则确定的位置上已有数, 或上一个数是第1行第n列时, 则把下一个数放在上一个数的下面.
       例如:　按上面的规定, 4应该放在第1行第2列, 但该位置已被1占据, 所以4就放在3的下面. 由于6是第1行第3列(即最后一列), 故7放在6下面
*/

#define N 15

int main(){
    int matrix[N][N], i, j, k, p, n;
    p = 1;

    // 输入1-15以内的奇数
    while (p==1){
        printf("enter n(n=1--15): ");
        scanf("%d", &n);
        if ((n!=0) && (n<=15) && (n%2)!=0)
            p = 0;
    }

    // 初始化
    for (i=1; i<=n; i++){
        for (j=1; j<=n; j++)
            matrix[i][j] = 0;
    }

    // 建立魔方阵
    j = n/2 + 1;
    matrix[1][j] = 1;
    for (k=2; k<=n*n; k++){
        i = i - 1;
        j = j + 1;
        if ((i<1) && (j>n)){
            i = i + 2;
            j = j - 1;
        } else {
            if (i<1) i=n;
            if (j>n) j=1;
        }
        if (matrix[i][j] == 0){
            matrix[i][j] = k;
        } else {
            i = i + 2;
            j = j - 1;
            matrix[i][j] = k;
        }
    }

    // 输出魔方阵
    for (i=1; i<=n; i++){
        for (j=1; j<=n; j++)
            printf("%5d", matrix[i][j]);
        printf("\n");
    }
    

    
    return 0;
}