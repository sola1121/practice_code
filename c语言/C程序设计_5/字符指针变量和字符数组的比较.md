1.字符数组由若干个元素组成,每个元素中放一个字符, 而字符指针变量中存放的是地址(字符串第一个字符的地址).

2.赋值方式. 可以对字符指针变量赋值, 但不能对数组名赋值.

    char *a;
    a = "Hello, World.";   // 将字符串首元素地址赋给指针变量.

    char a[14];
    a[0] = 'H';   // 对字符数组元素第0位进行赋值.
    × a = "Hello, World.";   // 数组名是地址, 是常量, 不能被赋值.

3.初始化含义不同. 数组可以在定义时对各元素赋初值, 但不能用赋值语句对字符数组中全部元素整体赋值.

    对于指针
    char *a = "Hello, World.";   // 定义字符指针变量a, 并把字符串第一个元素赋给a
    等价于
    char *a;   // 定义字符指针变量a
    a = "Hello, World.";   // 把字符串第一个元素的地址给a

    对于数组
    char a[14] = "Hello, World.";   // 定义字符数组a, 并把字符串赋给数组中各元素
    不能在非声明时为其整体赋值
    char a[14];   // 定义字符数组a
    × a[] = "Hello, World.";   // 尝试将字符创赋给字符数组中的各个元素, 错误

4.储存单元的内容. 编译时为字符数组分配若干储存单元, 以存放各元素的值, 而对字符指针变量, 只分配一个储存单元(一般的编译器给分配4个字节).

    如果定义了字符数组, 但未对它赋值, 这时数组中的元素的值是不可预料的. 可以引用(如输出)这些值, 结果显然是无意义的, 但不会造成严重的后果, 容易发现和改正.

    如果定义了字符指针变量, 应当及时把一个字符变量(或字符数组元素)的地址赋给它, 使它指向一个字符型数据, 如果未对它赋予一个地址值, 它并为具体指向一个确定的对象. 此时如果向该指针变量所指向的对象输入数据, 可能会出现严重后果.

5.指针变量的值是可以改变的, 而字符数组名代表一个固定的值(数组首元素的地址), 不能改变.

    # include "stdio.h"

    int main(){
        char *a = "Hello, World.";
        a = a + 4;   // 改变指针变量的值
        printf("%s\n", a);   // 输出: o, World.
        return 0;
    }

6.字符数组中各元素的值是可以改变的(可以对它们再赋值), 但字符指针变量指向的字符串常量中的内容是不可以被取代的(不能对它们再赋值).

    char a[] = "Hello!";
    a[0] = 'h';   // 取代数组元素a[0]的原值

    char *b = "Hello!";
    × char b[0] = 'h';   // 字符串常亮不能改变

7.引用数组元素.  
对字符数组可以用下标法(用数组名和下标)引用一个数组元素(如a[2]), 也可以用地址法(如*(a+2), 对应a[2])应用数组元素. 如果定义了字符指针变量p, 并使它指向数组a的首元素, 则可以用指针变量带下标的形式引用数组元素(如p[2]), 同样, 可以用地址法(如*(p+2), 对应a[2])应用数组元素.  
但是, 如果指针变量p没有指向数组, 则无法使用p[2]或*(p+2)这样引用数组中的元素. 若这时输出p[2]或*(p+2), 系统将输出指针变量p所指的字符后面的2个字节的内容. 显然这是没有意义且具有一定的危险性.

    若字符指针变量指向字符串常量, 就可以使用指针变量, 就可以使用指针变量带下标的形式引用所指的字符串中的字符.
    char *a = "Hello, World!";
    printf("%c, %c", a[2], *(a+3));

8.用指针变量指向一个格式字符串, 可以用它替代printf函数中的格式字符串.