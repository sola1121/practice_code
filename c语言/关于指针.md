# 关于指针

## 指针的含义

指针是C语言中一个形象化的名词, 形象的表示"指向"的关系, 其在物理上的实现是通过地址来完成的. 正如高级语言中的"变量", 在物理上是"命名的存储单元". 明确了"指针就是地址", 就比较容易理解了.

+ &a是变量a的地址, 也可称为变量a的指针.
+ 指针变量是存放地址的变量, 也可以说, 指针变量的值是一个指针.
+ 指针碧娜按量也可称为地址变量, 它的值是地址.
+ &是取地址运算符, &a是a的地址, 也可以说, &是取指针运算符. &a是变量a的指针(即指向变量a的指针).
+ 数组名是一个地址, 是数组首元素的地址, 也可以说, 数组名是一个指针, 是数组首元素的指针.
+ 函数名是一个指针(指向函数代码区的首字节), 也可以说函数名是一个地址(函数代码区首字节的地址).
+ 函数的实参如果是数组名, 传递给形参的是一个地址, 也可以说, 传递给形参的是一个指针.

## 指针与类型

对地址而而言, 其是有类型的, 其是按照指针型数据的存储方式存储的(在一些编译器中被分配四个字节). 指针型存储单元是专门用来存放地址的, 指针型数据的存储形式就是地址的存储形式.

它不是一个简单的纯地址, 还有一个指向的问题, 也就是说它指向的是哪种类型的数据. 如果没有这些信息, 是无法通过地址存取储存单元中的数据的. 所以, 一个指针型的数据实际上包含2个信息.

+ 表示内存编号的纯地址.
+ 指针类型, 也可理解为其指向的基类型

## 区别指针和指针变量

要区别指针和指针变量. 指针就是地址, 而指针变量是用来存放地址的变量. 有人认为指针是类型名, 指针的值是地址. 这是不对的. 类型是没有值的, 只有变量才有值, 正确对的说法是指针变量的值是一个地址. 地址本身就是一个值.

## 什么是"指向"

地址就意味着指向, 因为通过地址能找到具有该地址的对象. 对于指针变量来说, 把谁的地址存放在指针变量中, 就说此指针变量指向谁. 但应该注意: 并不是任何类型数据的地址都可以存放在同一个指针变量中的, 只有与指针变量的基类型形同的数据的地址才能存放在相应的指针变量中.

    int a, *p;
    float b;
    p = &a;   // p的基类型与a类型相同, 可以
    p = &b;   // p的基类型与b类型不同, 错误

既然许多数据对象(如变量, 数组, 字符串和函数等)都在内存中被分配存储控件, 就有了地址, 也就有了指针. 可以定义一些指针变量, 分别存放这行数据对象的地址, 即指向这些对象.

void*指针是一种特殊的指针, 不指向任何类型的数据. 如果需要用此地址指向某类型的数据, 应向对地址进行类型转换. 可以在程序中进行显示的类型转换, 也可以由编译系统自动进行隐式转换.

## 对数组的操作中正确地使用指针

在使用指针对数组进行操作的时候, 要搞清楚指针的指向.

    int * pt, array[10];
    pt = array;

pt是指向int型类型的指针变量, 显然, pt只能指向数组中的元素(int型变量), 而不是指向真个数组. 在进行赋值时一定要先确定赋值运算两端的类型是否相同, 是否允许赋值.

对 pt=array; 准确说应该是pt指向array数组的首元素, 在不引起误解的情况下, 有时也简称为: pt指向array数组. 同理, pt指向字符串, 也应理解为pt指向字符串中的首字符.

## 关于指针变量的归纳

|   变量定义    |   类型表示   |   含义   |
|     -        |      -     |     -    |
|  int i;      |  int       | 定义整形变量i
|  int *p;     |  int *     | 定义p为指向整形数据的指针变量
|  int a[5];   |  int [5]   | 定义整形数组a, 它有5个元素
|  int *p[4];  |  int *[4]  | 定义指针数组p, 它由4个指向整形数据的指针元素组成
|  int (*p)[4];|  int(*)[4] | p为指向包含4个元素的一维数组的指针变量
|  int f();    |  int ()    | f为返回整型函数值的函数
|  int *p();   |  int *()   | p为返回一个指针的函数, 该指针指向整型数据
|  int (*p)(); |  int (*)() | p为指向函数的指针, 该函数返回一个整型值
|  int **p;    |  int **    | p是一个指针变量, 它指向一个指向整型数据的指针变量
|  void * p;   |  void *    | p是一个指针变量, 基类型为void(空类型), 不指向具体的对象

### 指针数组

指针数组是用于存放指定类型的指针.

指向整数的指针数组的声明

    int *ptr[n];

在这里, 把ptr声明为一个数组, 由n个整数指针组成. 因此, ptr中的每个元素, 都是一个指向int值的指针. 如下, 将三个int地址, 存储到指针数组中.

    int arr[] = {1, 2, 3};

    for (int i=0; i<3; i++){
      ptr[i] = &arr[i];   // 赋值为整数的地址
    }

可以用一个指向字符的指针数组来存储一个字符串列表

    const char *names[] = {"AAA", "BBB", "CCC"};
 
    for (int i=0; i<3; i++){
       printf("Value of names[%d] = %s\n", i, names[i] );
    }

### 指向指针的指针

指向指针的指针是一种多级间接寻址的形式, 或者说是一个指针链. 通常, 一个指针包含一个变量的地址. 当定义一个指向指针的指针时, 第一个指针包含了第二个指针的地址, 第二个指针指向包含实际值的位置.

指针(地址) -> 指针(地址) -> 变量(保存值)

下面声明一个指向int*指针的指针.

    int ** ppt;

当一个目标值被一个指针间接指向到另一个指针时, 访问这个值需要使用两个星号运算符

    int  num;
    int  *ptr;
    int  **pptr;

    num = 3000;

    /* 获取 num 的地址 */
    ptr = &num;

    /* 使用运算符 & 获取 ptr 的地址 */
    pptr = &ptr;

    /* 使用 pptr 获取值 */
    printf("Value of num = %d\n", num );
    printf("Value available at *ptr = %d\n", *ptr );
    printf("Value available at **pptr = %d\n", **pptr);

### 传递指针给函数

    #include <stdio.h>
    #include <time.h>
    
    void getSeconds(unsigned long *par);

    int main (){
        unsigned long sec;

        getSeconds( &sec );

        /* 输出实际值 */
        printf("Number of seconds: %ld\n", sec );

        return 0;
    }

    void getSeconds(unsigned long *par){
        /* 获取当前的秒数 */
        *par = time( NULL );
        return;
    }

函数除接受指针, 也可以接受一个数组, 以下两种函数声明方式一样, arr为一个数组

    double getAverage(int *arr, int size);
    double getAverage(int arr[], int size);

### 返回指针的函数

C语言不支持在调用函数时返回局部变量的地址, 除非定义局部变量为static变量(使用静态存储空间).

下面的例子, 它会生成 10 个随机数, 并使用表示指针的数组名(即第一个数组元素的地址)来返回它们

    #include <stdio.h>
    #include <time.h>
    #include <stdlib.h> 
    
    /* 要生成和返回随机数的函数 */
    int * getRandom( ){
        static int  r[10];
        int i;
    
        /* 设置种子 */
        srand( (unsigned)time( NULL ) );
        for ( i = 0; i < 10; ++i){
            r[i] = rand();
            printf("%d\n", r[i] );
        }
        
        return r;
    }
    
    /* 要调用上面定义函数的主函数 */
    int main (){
        /* 一个指向整数的指针 */
        int *p;
        int i;
        
        p = getRandom();
        for ( i = 0; i < 10; i++ )
        {
            printf("*(p + [%d]) : %d\n", i, *(p + i) );
        }
        
        return 0;
    }

## 指针运算

1.指针变量加减一个整数, 将该指针变量的原值(是一个地址)和它指向的变量所占用的存储单元对的字节数相加减.

2.指针变量赋值, 将一个变量地址赋值给一个指针变量.

    p = &a;         // 将变量a的地址赋给p
    p = array;      // 将数组array首元素地址赋给p
    p = &array[i];  // 将数组array的第i个元素的地址赋给p
    p = max;        // max为已定义的函数, 将max的入口地址赋给p
    p1 = p2;        // p1和p2是基类型形同指针变量, 将p2的值赋给p1

3.两个指针变量可以相减. 如果两个指针变量都指向同一个数组中的元素, 则两个指针变量之差是两个指针之间的元素个数.

4.两个指针变量比较. 若两个指针指向同一个数组的元素, 则可以进行比较. 指向前面的元素的指针变量"小于"指向后面元素的指针变量. 如果p1和p2不指向同一数组则比较无意义. 地址的比较就是那十六位地址指向数值的比较.

## 指针变量可以有空值

指针变量不指向任何变量, 可以使用NULL指针.

    p = NULL;

NULL是一个符号常量, 代表整数0. 在stdio.h头文件中对NULL进行了定义.

    # define NULL 0

它使指针指向地址为0的单元. 系统保证该单元不作他用(不存放有效数据).

应注意, p的值为NULL与未对p赋值是两个不同的概念. 前者是有值的(值为0), 不指向任何变量, 后者虽未对p赋值但并不等于p无值, 只是它的值是一个无法预料的值(指向一个允许的随机地址, 内存不安全), 也就是p可能指向一个事先未指定的单元. 这种情况是危险的. 因此, 在引用指针变量之前应对它赋值.

任何指针变量或地址都可以与NULL做相等或不相等的比较

    if(p==NULL)
