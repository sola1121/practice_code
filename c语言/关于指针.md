# 关于指针

<!-- TOC -->

- [关于指针](#关于指针)
    - [为什么需要指针](#为什么需要指针)
    - [指针的含义](#指针的含义)
    - [指针与硬件的关系](#指针与硬件的关系)
    - [变量和内存](#变量和内存)
    - [指针变量和指向关系](#指针变量和指向关系)
        - [定义指针变量](#定义指针变量)
        - [解地址](#解地址)
        - [指针之间的赋值](#指针之间的赋值)
        - [坏指针](#坏指针)
    - [指针与类型](#指针与类型)
    - [区别指针和指针变量](#区别指针和指针变量)
    - [什么是"指向"](#什么是指向)
    - [指针的应用](#指针的应用)
        - [关于指针变量的归纳](#关于指针变量的归纳)
        - [结构体和指针](#结构体和指针)
        - [数组与指针](#数组与指针)
        - [指针数组](#指针数组)
        - [指向指针的指针](#指向指针的指针)
        - [函数和指针](#函数和指针)
            - [函数的参数和指针](#函数的参数和指针)
            - [函数的指针](#函数的指针)
            - [传递指针给函数](#传递指针给函数)
            - [返回指针的函数](#返回指针的函数)
        - [const和指针](#const和指针)
    - [指针运算](#指针运算)
    - [浅拷贝和深拷贝](#浅拷贝和深拷贝)
    - [指针变量可以有空值](#指针变量可以有空值)
    - [void* 类型指针](#void-类型指针)
    - [补充](#补充)
        - [大端模式和小端模式](#大端模式和小端模式)

<!-- /TOC -->

## 为什么需要指针

1.指针的使用使得不同区域的代码可以轻易的共享内存数据. 当然, 也可以通过复制达到相同的效果, 但这样效率没有直接来得好, 因为诸如结构体等大型数据, 占用的字节数多, 复制很消耗性能. 但是使用指针就可以很好的避免这个问题, 因为任何类型的指针占用的字节数都是一样的(根据平台的不同, 常见的有4字节或者8字节等).

2.指针使得一些复杂的链接性的数据结构的构建成为可能, 如链表, 链式二叉树等.

3.有些操作必须使用指针, 如操作申请堆内存.

补充: C语言中一切函数调用中, 实参传递给形参的机理都是"按值传递(pass by value)", 如果要在函数中修改传递过来的对象, 就必须通过这个对象的指针来完成.

## 指针的含义

指针是C语言中一个形象化的名词, 形象的表示"指向"的关系, 其在物理上的实现是通过地址来完成的. 正如高级语言中的"变量", 在物理上是"命名的存储单元". 明确了"指针就是地址", 就比较容易理解了. 那么指针是程序数据在内存中的地址, 那指针变量就是用来保存这些地址的变量. 任何程序数据载入内存后, 在内存都有它们的地址, 这是指针. 而为了保存一个数据在内存中的的地址, 这就需要指针变量.

+ &a是变量a的地址, 也可称为变量a的指针.
+ 指针变量是存放地址的变量, 也可以说, 指针变量的值是一个指针.
+ 指针碧娜按量也可称为地址变量, 它的值是地址.
+ &是取地址运算符, &a是a的地址, 也可以说, &是取指针运算符. &a是变量a的指针(即指向变量a的指针).
+ 数组名是一个地址, 是数组首元素的地址, 也可以说, 数组名是一个指针, 是数组首元素的指针.
+ 函数名是一个指针(指向函数代码区的首字节), 也可以说函数名是一个地址(函数代码区首字节的地址).
+ 函数的实参如果是数组名, 传递给形参的是一个地址, 也可以说, 传递给形参的是一个指针.

## 指针与硬件的关系

内存在物理上是由一组DRAM芯片组成的, 操作系统将DRAM等硬件和软件结合起来, 给用户提供一种对物理内存的抽象. 这种抽象机制使得程序使用的是虚拟存储器, 而不是直接操作物理存储器. 所有虚拟地址形成的集合就是虚拟地址空间.

也就是说, 虚拟存储其是一个很大的, 线性的字节数组(平坦寻址). 每一个字节都是固定的大小, 有8个二进制位(bit)组成. 最关键对的是, 每一个字节都有一个唯一的编号, 编号从0开始, 一直到随后一个字节. 比如在一个32位系统中, 一个4GB的内存, 将表现在虚拟存储器上为4×1024×1024×1024个字节, 那么它的虚拟地址范围就是0~4×1024×1024×1024-1.

由于内存中的每一个字节都有一个唯一的编号, 因此, 在程序中使用的变量, 常量, 函数等数据, 当它们被载入到内存中后, 都有自己唯一的一个编号, 这个编号就是这个数据的地址. 指针就是这样形成的.

指针的实质是内存单元(即字节)的编号, 所以指针单独从数值上看, 也是整数, 它们一般用16进制表示. 指针的值(虚拟地址值)使用一个机器字的大小来存储, 对于一个机器字为w位的电脑而言, 它的虚拟地址空间是0~pow(2, w) - 1, 程序最多能访问pow(2, w)个字节. 这就是为什么xp这种32位系统最大支持4GB内存的原因了.

## 变量和内存

定义一个局部变量int num = 97;, 来分析变量在内存中的存储模型. 已知: num类型是int, 占用了4个字节的内存空间, 其值是97, 地址 0028FF40.

1. 内存的数据

内存的数据就是变量的值对应的二进制, 一切都是二进制. 97的二进制是00000000 00000000 00000000 01100000, 但是使用小端模式存储时, 低位数据存放在低地址, 所以图中画的时候是倒过来的.

2. 内存数据的类型

内存的数据类型据定了这个数据占用的字节数, 以及计算机将如何解释这些字节. num的类型是int, 因此将被解释为一个整数. 相同的内存数据以不同的数据类型去解析的时候, 会得到不同的值, 所以数据的类型是非常重要的.

3. 内存数据的名称

内存的名称就是变量名. 实质上, 内存数据都是以地址来标识的, 根本没有内存的名称这个说法, 这只是高级语言提供的抽象机制, 方便操作内存数据. 而且在C语言中, 并不是所有的内存数据都有名称, 例如使用malloc申请内存就没有.

4. 内存数据的地址

如果一个类型占用的字节数大于1, 则变量的地址就是其占用的所有字节的地址值最小的那个字节的地址. 因此num的地址是 0028FF40. 内存的地址用于标志这个内存块.

5. 内存数据的生命周期

num是main函数中额局部变量, 因此当main函数被启动时, 它被分配于栈内存上, 当main执行结束时, 消亡.  
C语言中的程序数据会按照它们定义的位置, 数据的种类, 修饰的关键字等因素, 决定它们的生命周期特性. 实质上程序使用的内存会被逻辑上划分为: 栈区, 堆区, 静态数据区, 代码区. 不同区域的数据有不同的生命周期和读写权限.

## 指针变量和指向关系

用来保存指针(地址)的变量, 就是指针变量. 如果指针变量p保存了变量num的地址, 则就说p指向了变量num, 也可以说p指向了num所在的内存块, 这种指向关系, 一般用箭头表示.

    ━━━━━━━━━━━━━━━━━━━━━━━━━           ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━   
    ┃ int *p;  指向 0028FF40 ┃ - ... -> ┃  int num=97;   地址 0028FF40 0028FF41 0028FF42 0028FF43 ┃
    ━━━━━━━━━━━━━━━━━━━━━━━━━           ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 

pointer: 指针  
pointee: 被指向的数据对象  
A pointer stores the address of a pointee.

### 定义指针变量

C语言中, 定义变量时, 在变量名前写一个 * 星号, 这个变量就变成了对应变量类型的指针变量. 必要时加()来避免优先级问题.

    int a ; //int类型变量 a
    int* p ; //int* 变量p
    int arr[3]; //arr是包含3个int元素的数组
    int (* parr )[3]; //parr是一个指向【包含3个int元素的数组】的指针变量


    //-----------------各种类型的指针------------------------------

    int* p_int; //指向int类型变量的指针 

    double* p_double; //指向double类型变量的指针 

    struct Student *p_struct; //结构体类型的指针

    int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 

    int(*p_arr)[3]; //指向含有3个int元素的数组的指针 

    int** p_pointer; //指向 一个整形变量指针的指针

使用 & 运算符取得一个变量的地址.

    int add(int a , int b){
        return a + b;
    }

    int main(void){
        int num = 97;
        float score = 10.00F;
        int arr[3] = {1,2,3};

        //-----------------------

        int* p_num = &num;
        float* p_score = &score;
        int (*p_arr)[3] = &arr;           
        int (*fp_add)(int ,int )  = &add;  //p_add是指向函数add的函数指针
        return 0;
    }

对于某些数据结构, 其本身就是指针变量的一种表现形式, 如果使用指针变量来承接它, 可以不用&

+ 字符串字面两常量作为右值时, 就是这个字符串对应的字符数组的名称, 也就是这个字符串在内存中的地址
+ 数组名的值就是这个数组的的第一个元素的地址
+ 函数名的值就是这个函数的调用地址  

如下对字符串, 数组, 函数使用指针:

    int add(int a , int b){
        return a + b;
    }
    int main(void){
        int arr[3] = {1,2,3};
        //-----------------------
        const char* msg = "Hello world";
        int* p_first = arr;
        int (*fp_add)(int ,int )  =  add;
        return 0;
    }

### 解地址

使用指针变量, 操作(读/写)它指向的数据. 读一个指针解地址, 就可以取到这个内存数据, 解地址对的写法, 就是在指针前面加一个 * 星号.

    int main(void){
        int age = 19;
        int*p_age = &age;
        *p_age  = 20;  //通过指针修改指向的内存数据

        printf("age = %d\n",*p_age);   //通过指针读取指向的内存数据
        printf("age = %d\n",age);

        return 0;
    }

### 指针之间的赋值

指针的赋值和int变量赋值一样, 就是将地址的值拷贝给另外一个. 指针之间的赋值对于指向变量来说是一种浅拷贝, 是正在多个编程单元之间共享内存数据的高效方法.

    int *p1 = &num;
    int *p2 = p1;
    // 通过p1, p2, 都可以对内存数据num进行读写, 如果两个函数分别使用了p1和p2, 那么这两个函数就共享了数据

### 坏指针

指针变量的值是NULL, 或者未知的地址值, 或者是当前应用程序不可访问的地址值, 这样的指针就是坏指针, 不能对它们做解指针操作, 否则和产能需会出现运行时错误, 导致程序意外终止. 任何一个指针变量在做解地址操作前, 都必须保证它指向的是有效的, 可用的内存块, 否则就会出错. 坏指针是造成C语言bug最频繁的原因之一.

    // 错误示例
    int *p = NULL;
    *p = 10;   // 不能对NULL解地址

    int *p;
    *p = 10;   // 不能对一个未知的地址解地址

    int *p = (int *) 1000;
    *p = 10;   // 不能对一个可能不属于本程序的内存的地址的指针解地址

## 指针与类型

对地址而而言, 其是有类型的, 其是按照指针型数据的存储方式存储的(在一些编译器中被分配四个字节). 指针型存储单元是专门用来存放地址的, 指针型数据的存储形式就是地址的存储形式.

它不是一个简单的纯地址, 还有一个指向的问题, 也就是说它指向的是哪种类型的数据. 如果没有这些信息, 是无法通过地址存取储存单元中的数据的. 所以, 一个指针型的数据实际上包含2个信息.

+ 表示内存编号的纯地址.
+ 指针类型, 也可理解为其指向的基类型

指针的值: 变量int num=97;, 其地址值0028FF40, 因此, 指向它的指针变量的值就是0028FF40. 数据的地址用于在内存中定位和标识这个数据, 因为任何2个内存不重叠的不同数据对的地址都是不同的.  
指针的类型: 指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息. 一般指针变量的类型要和它指向的数据的类型匹配.

    int main(void){
        int num = 97;
        int *p1  = &num;
        char* p2 = (char*)(&num);

        printf("%d\n",*p1);    //输出  97
        putchar(*p2);          //输出  a
        return 0;
    }

*p1: 将从地址0028FF40开始解析, 因为p1是int类型指针, int占4字节, 因此向后连续取4个字节, 并将这4个字节的二进制数据解析为一个整数97.  
*p2: 将从地址0028FF40开始解析, 因为p2是char类型指针, char占1个字节, 并将这1个字节的二进制数据解析为一个字符, 即'a'.

同样的地址, 因为指针的类型不同, 对它指向的内存的解释就不同, 得到的就是不同的数据.

## 区别指针和指针变量

要区别指针和指针变量. 指针就是地址, 而指针变量是用来存放地址的变量. 有人认为指针是类型名, 指针的值是地址. 这是不对的. 类型是没有值的, 只有变量才有值, 正确对的说法是指针变量的值是一个地址. 地址本身就是一个值.

## 什么是"指向"

地址就意味着指向, 因为通过地址能找到具有该地址的对象. 对于指针变量来说, 把谁的地址存放在指针变量中, 就说此指针变量指向谁. 但应该注意: 并不是任何类型数据的地址都可以存放在同一个指针变量中的, 只有与指针变量的基类型形同的数据的地址才能存放在相应的指针变量中.

    int a, *p;
    float b;
    p = &a;   // p的基类型与a类型相同, 可以
    p = &b;   // p的基类型与b类型不同, 错误

既然许多数据对象(如变量, 数组, 字符串和函数等)都在内存中被分配存储控件, 就有了地址, 也就有了指针. 可以定义一些指针变量, 分别存放这行数据对象的地址, 即指向这些对象.

void*指针是一种特殊的指针, 不指向任何类型的数据. 如果需要用此地址指向某类型的数据, 应向对地址进行类型转换. 可以在程序中进行显示的类型转换, 也可以由编译系统自动进行隐式转换.

## 指针的应用

### 关于指针变量的归纳

|   变量定义    |   类型表示   |   含义   |
|     -        |      -     |     -    |
|  int i;      |  int       | 定义整形变量i
|  int *p;     |  int *     | 定义p为指向整形数据的指针变量
|  int a[5];   |  int [5]   | 定义整形数组a, 它有5个元素
|  int *p[4];  |  int *[4]  | 定义指针数组p, 它由4个指向整形数据的指针元素组成
|  int (*p)[4];|  int(*)[4] | p为指向包含4个元素的一维数组的指针变量
|  int f();    |  int ()    | f为返回整型函数值的函数
|  int *p();   |  int *()   | p为返回一个指针的函数, 该指针指向整型数据
|  int (*p)(); |  int (*)() | p为指向函数的指针, 该函数返回一个整型值
|  int **p;    |  int **    | p是一个指针变量, 它指向一个指向整型数据的指针变量
|  void * p;   |  void *    | p是一个指针变量, 基类型为void(空类型), 不指向具体的对象

### 结构体和指针

结构体有特殊的语法: -> 符号

如果p是一个结构体指针, 则可以使用p -> \[成员]的方法访问结构体成员. p -> member 等价于 (*p).member.

    typedef srtuct{
        char name[31];
        int age;
        float height;
    } People;

    int main(void){
        People human = {"Bob", 20, 1.7};
        People *ps = &human;

        ps->age = 24;
        ps->height = 1.73;

        printf("name: %s, age: %d, height: %f\n", ps->name, ps->age, ps->height);
        
        return 0;
    }

### 数组与指针

在使用指针对数组进行操作的时候, 要搞清楚指针的指向.

    int * pt, array[10];
    pt = array;

pt是指向int型类型的指针变量, 显然, pt只能指向数组中的元素(int型变量), 而不是指向整个数组. 在进行赋值时一定要先确定赋值运算两端的类型是否相同, 是否允许赋值.

对 pt=array; 准确说应该是pt指向array数组的首元素, 在不引起误解的情况下, 有时也简称为: pt指向array数组. 同理, pt指向字符串, 也应理解为pt指向字符串中的首字符.

对数组进行加减一个整数, 就是让原来指向的内存块的下一个相邻的同类型的内存块.

    p[n] == *(p+n);
    p[n][m] == *(*(p+n)+m);

当对数组名使用sizeof时, 返回的是整个数组占用的内存字节数. 当把数组名赋值给一个指针后, 再对指针使用sizeof运算符, 返回的是指针的大小.

这就是为什么将一个数组传递给一个函数时, 需要另外用一个参数传递数组元素个数的原因.

### 指针数组

指针数组是用于存放指定类型的指针.

指向整数的指针数组的声明

    int * ptr[n];

在这里, 把ptr声明为一个数组, 由n个整数指针组成. 因此, ptr中的每个元素, 都是一个指向int值的指针. 如下, 将三个int地址, 存储到指针数组中.

    int arr[] = {1, 2, 3};

    for (int i=0; i<3; i++){
      ptr[i] = &arr[i];   // 赋值为整数的地址
    }

可以用一个指向字符的指针数组来存储一个字符串列表

    const char *names[] = {"AAA", "BBB", "CCC"};
 
    for (int i=0; i<3; i++){
       printf("Value of names[%d] = %s\n", i, names[i] );
    }

### 指向指针的指针

指向指针的指针是一种多级间接寻址的形式, 或者说是一个指针链. 通常, 一个指针包含一个变量的地址. 当定义一个指向指针的指针时, 第一个指针包含了第二个指针的地址, 第二个指针指向包含实际值的位置.

指针(地址) -> 指针(地址) -> 变量(保存值)

下面声明一个指向int*指针的指针.

    int ** ppt;

当一个目标值被一个指针间接指向到另一个指针时, 访问这个值需要使用两个星号运算符

    int  num;
    int  *ptr;
    int  **pptr;

    num = 3000;

    /* 获取 num 的地址 */
    ptr = &num;

    /* 使用运算符 & 获取 ptr 的地址 */
    pptr = &ptr;

    /* 使用 pptr 获取值 */
    printf("Value of num = %d\n", num );
    printf("Value available at *ptr = %d\n", *ptr );
    printf("Value available at **pptr = %d\n", **pptr);

### 函数和指针

#### 函数的参数和指针

C语言中, 实参传递给形参, 是按值传递的, 也就是说, 函数中的形参是实参的拷贝, 形参和实参只是在值上面一样, 而不是同一个内存数据对象. 这就意味着: 这种数据传递是单向的, 即从调用者传递给被调用函数, 而被调用函数无法修改传递的参数达到回传的效果.

有时候可以使用函数的返回值来回传数据, 在简单的情况下是可以的, 到那时如果返回值有其它用途(例如返回函数执行状态量), 或者要回传的数据不止一个, 返回值就解决不了.

传递变量的指针可以轻松结局上面描述的问题.

用函数交换2个变量的值的例子

    void swap_error(int, int);
    void swap_right(int*, int*);

    int main(){
        int a=1, b=2;

        swap_error(a, b);   // 不能交换
        swap_right(&a, &b);   // 可以交换

        return 0;
    }

    void swap_error(int x, int y){   // 错误的写法, 形参是实参的副本, 交换了不会影响实参
        int t;
        t = x;
        x = y;
        y = t;
    }

    void swap_right(int * x, int * y){   // 正确的写法, 形参指向的是实参指向的地址, 直接对地址指向上的值进行交换
        int t;
        t = *x;
        *x = *y;
        *y = t;
    }

#### 函数的指针

每一个函数本身也是一种程序数据, 一个函数包含了多条执行语句, 它被编译后, 是实质上是多条机器指令的合计. 在程序载入到内存后, 函数的机器指令存放在一个特定的逻辑区域--代码区. 既然是存放在内存中, 那么函数也是有自己的指针的.

C语言中, 函数名作为右值时, 就是这个函数的指针.

    void echo(const char *msg){
        printf("%s\n", msg);
    }

    int main(){
        void (*func_p) (const char*) = echo;   // 函数指针变量指向这个函数

        (*func_p)("Hello, World.");   // 通过函数的指针func_p调用函数, 等价于echo("Hello, World.");

        return 0;
    }

#### 传递指针给函数

    #include <stdio.h>
    #include <time.h>
    
    void getSeconds(unsigned long *par);

    int main (){
        unsigned long sec;

        getSeconds( &sec );

        /* 输出实际值 */
        printf("Number of seconds: %ld\n", sec );

        return 0;
    }

    void getSeconds(unsigned long *par){
        /* 获取当前的秒数 */
        *par = time( NULL );
        return;
    }

函数除接受指针, 也可以接受一个数组, 以下两种函数声明方式一样, arr为一个数组

    double getAverage(int *arr, int size);
    double getAverage(int arr[], int size);

#### 返回指针的函数

C语言不支持在调用函数时返回局部变量的地址, 除非定义局部变量为static变量(使用静态存储空间).

下面的例子, 它会生成 10 个随机数, 并使用表示指针的数组名(即第一个数组元素的地址)来返回它们

    #include <stdio.h>
    #include <time.h>
    #include <stdlib.h> 
    
    /* 要生成和返回随机数的函数 */
    int * getRandom( ){
        static int  r[10];
        int i;
    
        /* 设置种子 */
        srand( (unsigned)time( NULL ) );
        for ( i = 0; i < 10; ++i){
            r[i] = rand();
            printf("%d\n", r[i] );
        }
        
        return r;
    }
    
    /* 要调用上面定义函数的主函数 */
    int main (){
        /* 一个指向整数的指针 */
        int *p;
        int i;
        
        p = getRandom();
        for ( i = 0; i < 10; i++ )
        {
            printf("*(p + [%d]) : %d\n", i, *(p + i) );
        }
        
        return 0;
    }

### const和指针

const 到底修饰谁? 谁才是不变的? 下面的一些经验

如果const和面是一个类型, 则跳过最近的原子类型, 修饰后面的数据. (原子类型是不可再分隔的类型, 如int, short, float, 以及typedef包装后的类型)

如果const后面就是一个数据, 则直接修饰这个数据.

    int main(){
        int a = 1;

        int const *p1 = &a;   // const后面是*p1, 实质是数据a, 则修饰*p1, 通过p1不能修改a的值
        const int *p2 = &a;   // const后面是int类型, 则跳过int

        int * const p3 = NULL;   // const后面是数据p3. 也就是指针p3本身是const常量

        const int * const p4 = &a;   // 通过p4不能改变a的值, 同时p4本身也是const
        int const * cosnt p5 = &a;   // 通过p5不能改变a的值, 同时p5本身也是const

        return 0;
    }

typedef包装的

    typeddef int * point_int;   // 将int* 类型包装为point_int, 则point_int现在是一个完整的原子类型

    int main(){
        int a = 1;

        const point_int p1 = &a;   // const跳过point_int类型, 修饰p1, 指针p1本身是const常量
        point_int const p2 = &a;   // 同样, const跳过point_int, 直接修饰p2

        return 0;
    }

## 指针运算

1.指针变量加减一个整数, 将该指针变量的原值(是一个地址)和它指向的变量所占用的存储单元对的字节数相加减.

2.指针变量赋值, 将一个变量地址赋值给一个指针变量.

    p = &a;         // 将变量a的地址赋给p
    p = array;      // 将数组array首元素地址赋给p
    p = &array[i];  // 将数组array的第i个元素的地址赋给p
    p = max;        // max为已定义的函数, 将max的入口地址赋给p
    p1 = p2;        // p1和p2是基类型形同指针变量, 将p2的值赋给p1

3.两个指针变量可以相减. 如果两个指针变量都指向同一个数组中的元素, 则两个指针变量之差是两个指针之间的元素个数.

4.两个指针变量比较. 若两个指针指向同一个数组的元素, 则可以进行比较. 指向前面的元素的指针变量"小于"指向后面元素的指针变量. 如果p1和p2不指向同一数组则比较无意义. 地址的比较就是那十六位地址指向数值的比较.

## 浅拷贝和深拷贝

如果2个程序单元(例如两个函数)是通过拷贝它们所共享的数据的指针来工作的, 这就是浅拷贝, 因为真正要访问的数据并没有被拷贝. 如果被访问的数据被拷贝了, 在每个单元中都有自己的一份, 对目标数据的操作相互不受影响, 则叫深拷贝.

## 指针变量可以有空值

指针变量不指向任何变量, 可以使用NULL指针.

    p = NULL;

NULL是一个符号常量, 代表整数0. 在stdio.h头文件中对NULL进行了定义.

    # define NULL 0

它使指针指向地址为0的单元. 系统保证该单元不作他用(不存放有效数据).

应注意, p的值为NULL与未对p赋值是两个不同的概念. 前者是有值的(值为0), 不指向任何变量, 后者虽未对p赋值但并不等于p无值, 只是它的值是一个无法预料的值(指向一个允许的随机地址, 内存不安全), 也就是p可能指向一个事先未指定的单元. 这种情况是危险的. 因此, 在引用指针变量之前应对它赋值.

任何指针变量或地址都可以与NULL做相等或不相等的比较

    if(p==NULL)

## void* 类型指针

由于void是空类型, 因此void*类型的指针只保存了指针的值, 而丢失了类型信息, 不知道它指向的数据是什么类型的, 只知道这个数据在内存中的起始地址, 如果想要完整的提取指向的数据, 就必须对这个指针做出正确的类型转换, 然后再解指针. 数据的类型正确解析出内存数据的关键, 相同的内存数据以不同的数据类型去解析的时候, 会得到不同的值. 程序需要得到什么数据, 不光要知道其地址, 还要明确其类型, 因此编译器不允许直接对void\*类型做解指针操作.

## 补充

指针和引用这个2个名词的区别. 它们本质上来虽说是同样的东西. 指针常用在C语言中, 而引用, 则用于诸如Java, C#等在语言层面封装了对指针的直接操作的编程语言中. 引用是编程语言提供给用户的抽象机制, 而指针是操作系统提供给软件开发模型的抽象机制.

### 大端模式和小端模式

1) Little-Endian就是数据的低字节排放在内存的低地址端, 高字节排放在内存的高地址端. 个人PC常用, Intel x86处理器是小端模式.

2) Big-Endian就是数据的高字节排放在内存的低地址端.

采用大端方式进行数据存放符合人类的正常思维, 而采用小端方式进行数据存放利于计算机处理. 有些机器同时支持大端和小端模式

假如short类型占用2个字节, 且存储对的地址为0x30. 则short a = 1;

|   地址    |     0x30     |     0x31     |
|     -     |      -       |      -      |
|  小端模式  |  00000001    |   00000000   |
|  大端模式  |  00000000    |   00000000   |

测试当前机器使用的是什么模式

    #include<stdio.h>

    //测试机器使用的是否为小端模式。是，则返回true，否则返回false
    //这个方法判别的依据就是：C语言中一个对象的地址就是这个对象占用的字节中，地址值最小的那个字节的地址。
    int isSmallIndain(void){
        unsigned short val = 0x0001;
        unsigned char* p = (unsigned char*)&val;  //C/C++：对于多字节数据，取地址是取的数据对象的第一个字节的地址，也就是数据的低地址
        
        return (*p == 0x01);
    }
    
    int main(void){

        if(isSmallIndain()){
            puts("小端"); 
        } else{
            puts("大端"); 
        }

        return 0;

    }

第二种方法, 使用union

    #include<stdio.h>


    typedef union {
        unsigned short us;
        unsigned char  uc;
    }Test_t;
    
    int main(void){
        Test_t val;
        val.us = 0x0001;
        
        if(val.uc==0x01)
        {
            puts("小端"); 
        } else{
            puts("大端"); 
        }

        return 0;

    }
