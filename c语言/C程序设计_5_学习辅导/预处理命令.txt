0. 预处理指令(preprocessing direcitve)

    由C标准建议提出, 其本身不是C语言的组成部分, 不能用C编译系统直接对他们进行编译(因为编译程序不能识别).     
    在程序正式编译(包括词法和语法分析,生成代码,优化等)前, 由预处理器(preprocessor)对这些指令进行处理. 
    预处理将这些指令转换成相应的程序段, 这些程序段和程序中的其他部分组成完整的可以编译的C语言代码, 然后进行编译.
    其本质就是字符替换, 将预先定义的符号常量替换为其定义内容额字符.

    在预处理阶段, 预处理器把程序中的注释全部删除, 对预处理指令进行处理. 
        如将#include 指令指定的头文件的内容复制到#include 指令处
        对#define 指令, 进行指定的字符串替换
    同时删去这些预处理指令.

    经过处理后的待编译代码不包含任何预处理指令, 再由编译器生成可执行的目标代码.

    1) 预处理指令的常用功能
        1. 宏定义
        2. 文件包含
        3. 条件编译

    2) 格式样式
        为了与C语言相区别, 这些指令以符号"#"开头, 指令后面没有分号.

1. 宏定义

    1) 定义符号常量.
        # define 标识符 字符串

        解除定义的符号常量.
        # undef 标识符

        如
            # define PI 3.141592
            ...
            # undef PI
        在程序文件中, 将会由3.141592 来替换所有未在字符串中出现的PI. 这个PI标识符一般就就做宏名, 在预处理时将宏名替换为字符串的过程称为宏展开.

        宏名习惯上由大写字母表示, 以便避免与程序中变量名混淆.

        注意:
            宏定义只是用宏名代替一个字符串, 也就是只做简单的替换, 构成C代码的一部分, 但是不会进行正确性检查.
            宏定义不是C语句, 不必在行末加分号. 如果有了分号, 则会连带分号一起进行置换.
            #define 指令出现在程序中的函数外面, 宏名的有效范围为该指令行起到本源文件结束. 通常, #define 指令写在文件开头, 函数之前, 作为文件一部分, 在整个文件范围内有效. 可以用#undef 终止宏名的定义.
            在进行宏定义的时候, 可以引用以定义的宏名, 即可以层层置换.
            程序中用双撇号括起来的字符串内的字符, 即使与宏名相同, 也不进行置换.
            宏定义与定义变量的含义不同, 不分配存储空间. 不带参数的宏定义只作简单的字符替换.

    2) 带参数的宏定义
        # define 宏名(参数表) 字符串
        字符串中包含在括号中所指定的参数
        如
            # define SUM(a, b) a+b
            ...
            sum = SUM(3, 2);
        在预处理时将会被替换为 sum = 3+2;

        在程序中如果有带实参的宏, 则按#define 指令行中指定的字符串从 左→右 进行置换. 
        如果字串中包含宏中的形参, 则将程序语句中相应的实参(可以是常量,变量,表达式)代替形参. 
        如果宏定义中的字符串中的字符不是参数字符, 则保留.
        这样就形成了置换的字符串.

        如
            # define PI 3.141592
            # define AREA(r) PI*r*r
            ...
            area = AREA(radius);
        对带参数的宏的展开, 只是将语句中的宏名后面括号内的实参字符串代替#define 指令中的形参.
        在对area的赋值语句进行替换的时候, 找到#define指令中的AREA(r), 将AREA(radius)中的实参字符radius代替宏定义中的PI*r*r中的形参r. 得到PI*radius*radius.

        如果给出 area = AREA(x + y);
        则会出现 area = PI*x + y*x + y;
        这可能并不是想要的替换结果, 可以在定义的时候加上括号 # define AREA(r) PI*(r)*(r)

        注意:
            在定义宏时, 在宏名与带参数的括号之间不应该加空格, 否则会将空格以后的字符都做为替代字符串的一部分
            如
                # define AREA (r) PI*(r)*(r)
                这样会将AREA看作符号常量, AREA后面的(r) PI*(r)*(r)将被用作替换字符串

        (1) 带参数的宏定义与函数的区别
            函数调用时, 先求出实参表达式的值, 然后代入形参. 而使用带参数的宏只是进行字符替换
            函数调用是在程序运行时处理的, 为形参分配临时的内存单元. 而宏置换则是在预处理阶段进行的, 在置换时并不分配内存单元, 不进行值的传递处理, 也没有返回值概念
            对函数中的实参和形参都要定义类型, 二者的类型要求一致, 如不一致, 应进行类型转换. 而宏不存在类型问题, 宏名无类型, 他的参数也无类型, 只是一个符号代表, 置换时, 代入指定的字符串即可. 
            定义宏时, 字符串可以是任何类型的数据
            调用函数只可得到一个返回值, 而用宏可以设法得到几个结果
            使用宏次数越多时, 宏展开后源程序变长, 因为每展开一次都是代码量增长, 而函数调用不会使源程序变长
            宏替换不占运行时间, 而函数调用则占运行时间(分配单元, 保留现场, 值传递, 返回)

        (2) 适用例子
            一般将宏用来代表简短的表达式比较合适

            例子
                # define PI 3.141592
                # define CIRCLE(r) printf("圆的周长:%lf, 圆的面积:%lf\n", 2*PI*(r), PI*(r)*(r))
                ...
                CIRCLE(redius);

            可以拼接来写

            例子
                # define PR printf
                # define INTEGER "输出: %d"
                # define ENDLN "\n"

                # define PRINT_1 INTEGER ENDLN
                # define PRINT_2 INTEGER INTEGER ENDLN
                ...
                int a=1, b=2;
                PR(PRINT_1, a);
                PR(PRINT_2, a, b);
                ...
                可以使用puts(PRINT_1); 来查看拼和置换后的字符串

                若使用#undef ENDLN 释放, 那么PRINT_1和PRINT_2 就都没法用了

            可以发现, 如果是纯字符型的, 原内容需使用双撇号括起来, 这样会自动拼接

2. 文件包含
    # include <文件名>
    # include "文件名"

    作用
        包含以上指令的源文件, 会将指定文件名的另外一个源文件包含进来, 即将另外的文件内容包含到文本文件之中, 替换指令位置.
        在进行编译的时, 不是分别对源文件和被包含的源文件进行编译, 然后再将他们的目标程序连接的.
        而是在预处理时将被包含的源文件内容包含到主源文件中(取代#include 指令), 得到一个新的源程序
        即被包含的源文件中的内容成为新的源文件的一部分.

    这种常用在文件头部的被包含的文件称为标题文件或头文件, 常以 .h (header)作为后缀.
    当然不用.h 用 .c也可以, 只是这样能更明确的表现该文件的作用.

    1) <> 与 "" 的区别
        使用<> 包含文件名的时候, 预处理器将会到存放C库函数头文件的目录中寻找要包含的文件, 这称为标准方式.
        使用"" 包含文件名的时候, 预处理器将会先在用户当前目录中寻找要包含的同名文件, 若找不到, 再按标准方式寻找.
        另外, 若该头文件没有放在用户当前目录或库文件目录中, 可以使用"" 指明头文件的路径, 如: #include "/usr/share/c/file.h"

    2) 使用要点
        (1) 一个#include 指令只能指定一个被包含的文件, 如果要包含n个文件, 要用n格#include 指令.
        (2) 如果文件1需要包含文件2, 而文件2又需要用到文件3的内容, 则可以文件1中用两个#include 指令分别包含文件3和文件2.
            文件3应该出现在文件2之前. 因为#include 是将文件中的字符内容复制到源文件指令位置.
            所以可以看做, 先有了文件3的内容, 然后后面文件2的内容又被复制进来, 自然能使用先前复制进来的3中的内容.
        (3) 针对上面问题, 其实在一个被包含文件中又可以包含另一个文件, 即文件可以嵌套. 
            上面只需文件2提前在自己中#include 文件3, 然后源文件也就只需包含文件2就可以了. 同样的这三个文件的内容也是被复制合在一起.
        (4) 头文件除了可以包括函数原型和宏定义外, 也可以包括结构体类型定义和全局变量定义等.

3. 条件编译
    # ifdef 标识符
        程序段
    # endif

    作用
        若自定的标识符已经被#define 指令定义过, 就保留程序段, 否则在编译前将程序段删除
   
    # ifdef 标识符
        程序段1
    # else
        程序段2
    # endif

    作用
        若自定的标识符已经被#define 指令定义过, 则在程序编译阶段对程序段1进行编译, 否则编译程序段2.
        实际上预处理器发现所指定的标识符已经被#define 定义过, 就保留源程序中的程序段1, 而将程序段2删除, 否则就保留程序段2, 删除程序段1.
        在最后编译的源程序中只包含程序段1或2.

    这里的程序段可以是语句组, 也可以是指令行.

    # ifndef 标识符
        程序段1
    # else
        程序段2
    # endif

    作用
        若指定的标识符未被定义过, 则保留程序段1, 删除程序段2, 否(定义了对应标识符)则保留程序段2, 删除程序段1
        这样在编译源文件的时候, 就只有一个程序段
        ifndef 就是 if not define
    
    # if 表达式
        程序段1
    # else
        程序段2
    # endif

    作用
        当指定的表达式值为真(非零)时就保留程序段1, 删除程序段2, 否则(表达式为任意非零数)保留程序段2, 删除程序段1
        这样在编译源文件的时候, 就只有一个程序段

    1) 使用优势
        使用条件预编译, 可以减少被编译的语句, 从而减少目标程序的长度, 减少运行时间. 当条件编译较多时, 目标程序长度可以大大减少.

    以上的预处理功能都是C语言特有的, 有利于程序的可移植性

    2) 使用示例

        # ifdef COMPUTER_64
            # define INTEGER_SIZE 8
        # else
            # define INTEGER_SIZE 4
        # endif

        若在以上条件编译指令前出现 #define COMPUTER_64, 那么#ifdef 下面的留下, #else 下面的删了

        # ifdef DEBUGE
            printf("错误码: %d, 描述: %s", err, decr);
        # endif

        可以这样用来切换是否打印一些额外额信息

        # define IS_PRINT 1
        int main(){
            ...
            # if IS_PRINT
                puts("打印");
            # endif
            ...
        }

        判断是否执行, 注意, #if 后面跟的是可以反映真假的表达式

        注意, # define DO 就算宏定义的时候, 不定义任何内容, 也算是定义了的