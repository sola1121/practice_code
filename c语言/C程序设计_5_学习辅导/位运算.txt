0. 位运算
    位运算是指以二进制为对象的运算

    优先级2, 左←右, 单目运算符
        ~ 按位取反

    优先级5, 左→右, 双目运算符    
        << 左移
        >> 右移

    优先级8, 左→右, 双目运算符
        & 按位与

    优先级9, 左→右, 双目运算符
        ^ 按位异或

    优先级10, 左→右, 双目运算符
        | 按位或
    
    优先级14, 左←右, 双目运算符
    =  : 赋值
    *= : 乘后赋值
    /= : 除后赋值
    %= : 取余后赋值
    += : 加后赋值
    -= : 减后赋值
    <<= : 左移后赋值
    >>= : 右移后赋值
    &=  : 按位与后赋值
    ^=  : 按位异或后赋值
    |=  : 按位或后赋值
    
    参加位运算的对象只能是整型或字符型的数据, 负数都是以补码的形式参加运算的

    ~ 0变1, 1变0
    << 左移指定位数, 相当与×2ⁿ
    >> 右移指定位数, 相当于÷2ⁿ
    & 都是1, 返1, 有个0, 返0
    ^ 两个不同返1, 两个相同返0
    | 都是0, 返0, 有个1, 返1

补充
    二进制, 逢2进1
        0, 1, 10, 11, 100, 101, 110, 111, 1000
    正十进制转二进制, 除2取余, 倒排余数, 高位0占
        19 ÷ 2 = 9 ... 1
        9  ÷ 2 = 4 ... 1
        4  ÷ 2 = 2 ... 0
        2  ÷ 2 = 1 ... 0
        1  ÷ 2 = 0 ... 1
        倒着取余数 -> 10011
        若按一个整数一字节, 补到8位 -> 00010011
        即为19 的二进制
    正二进制转十进制, 按位乘2的对应次方
        00010011 共8位, 按位数排下来是 7,6,5,4,3,2,1,0
        0*pow(2,7) + 0*pow(2,6) + 0*pow(2,5) + 1*pow(2,4) + 0*pow(2,3) + +0*pow(2,2) + 1*pow(2,1) + 1*pow(2,0) == 19
    负十进制转二进制, 对应的正十进制转为二进制后, 对该二进制取反~, 然后加1 (取补码)
        00010011 - 取反~ -> 11101100 -在加1-> 11101101   (实际代表-18)
    负二进制转十进制
        如果最高位为0, 这是一个正数, 补码和原码相同
        如果最高位为1, 这是一个负数, 需要取反~, 在按正二进制转十进制方法计算
            11101101 - 取反~ -> 00010010 -> 1*pow(2,4) + 0*pow(2,3) + 0*pow(2,2) + 1*pow(2,1) + 0*pow(2,0) == -18
    小数转二进制, 对小数点后面的数乘2, 取结果个位(为0或1), 在接着用这个结果的小数部分乘2, 取结果个位(0或1)...直到小数部分为0或者位数已够
        0.125 转二进制
        0.125*2 = 0.25 取个位 0
        0.25 *2 = 0.5  取个位 0
        0.5  *2 = 1.0  取个位 1
        小数部分为0, 结束
        则获得0.125的二进制为 0.001
        用二个字节表示一个浮点数, 那么19.125 二进制:0.0001, 科学记数法 1*pow(2,-4), 后移动四位, 在内存中表现 0001001100010000
    二进制转小数, 按位乘2的对应次方
        二进制 0.1101, 从个位按位数排下来是 0,-1,-2,-3,-4
        0*pow(2,0) + 1*pow(2,-1) + 1*pow(2,-2) + 0*pow(2,-3) + 1*pow(2,-4) == 0.8125

1. 按位取反
    反 ~ 运算
    对二进制数按位取反, 即将0变1, 将1变0

    ~ 为单目运算符, 左←右, 比算术运算符, 关系运算符, 逻辑运算符和其他运算符优先级都高

    1) 例
        ~25
        0000000000011001
      ~  
      -------------------
        1111111111100110   十进制 65510
    
    2) 应用
        让一个数的最后一位为0, 如1101, 想让最后一个1变为0, 配合& 与运算, 1101&1110
        可以这样 num & ~1 即可

2. 左移
    << 左移运算符, 左→右, 双目运算符
    用来将一个数的各二进制位全部左移若干位, 右补0, 溢位舍

    左移一位相当于乘以2, 移动若干位, 相当于乘以2的对应次方. 这个情况只适用于该数左移时被溢出舍弃的高位中不包含1的情况.

    1) 例
        15<<2
        00001111
    <<2  
    -------------
        00111100   十进制 60

        相当于 15 * pow(2, 2), 即 15 * 4

        -15<<2
        11110001
    <<2
    -------------
        11000100   表示为十进制 -60

        和正数左移一样, 在负数的二进制位右边补0, 一个数在左移的过程中会有正负切换的情况, 所以负数左移不会特殊处理符号位.
        如果一直左移, 最终会变成0.

    2) 应用
        左移运算比乘法运算要快, 可以使用左移来代替乘以2即其次方的情况

3. 右移
    >> 右移运算符, 左→右, 双目运算符
    用来将一个数的各二进制位全部右移若干位, 对无符号, 左补0, 溢位舍

    右移一位相当于处以2, 移动若干位, 相当与除以2的对应次方.

    右移时, 需注意符号位问题. 对无符号数, 右移时左边高位补0. 
    对与有符号的数, 如果原来符号位是0, 则补0, 如果符号位为1, 根据系统或编译器的不同, 会补1保证符号和补0依照运算两种.
    补1称为 算术右移, 补0称为 逻辑右移.
    VC++ 中 msvc, GNU GCC编译器都是算术右移.

    1) 例
        -6125>>2
        1001011111101101
    >>2 
    ---------------------
        1000010111111011   表示为十进制 -1531 
    
    这是算术右移, 补了符号1

4. 按位与
    与 & 运算
    对应二进制位都是1, 返1, 否则为0
    即: 0&0=0, 0&1=0, 1&0=0, 1&1=1

    1) 例
        7&5=5
          00000111
        & 00000101
        -----------
          00000101

        -7&-5
          11111001
        & 11111011
        -----------
          11111001

    2) 应用
        (1) 清零
            如果像将一个单元清零, 即使使其全部二进制位为0. 只需找到一个新数, 对应原来数中为1的位, 新数的对应位为0.
            拿不准就找0, num&0 = 0

        (2) 取一个数中某些指定位
            如有一个短整数, 想要其中的低字节, 可以 & 0377 (八进制)
                0010110010101100
              & 0000000011111111
              -------------------
                0000000010101100
            因为0377前八位都是0, 后八位又都为1, 这样就保留了短整数后八位

            如有一个短整数, 想要其中的高字节, 可以 & 0177400 (八进制)
                0010110010101100
              & 1111111100000000
              -------------------
                0010110000000000
            因为0177400前八位都是1, 后八位又都是0, 这样就保留了短整数前八位


        (3) 要想将哪一位保留下来, 就与一个数进行与(&)运算, 次数在该位取1
            想要将01010100中左面第3, 4, 5, 7, 8位(以1开始数)保留下来
                01010100   十进制 84
              & 00111011   十进制 59
              -----------
                00010000   十进制 16

5. 按位异或
    异或 ^ 运算
    参加运算的两个二进制位不同(异), 则返1, 否则为0
    即: 0^0=0, 0^1=1, 1^0=1, 1^1=0

    1) 例
        00111001   十进制 57
      ^ 00101010   十进制 42
      -----------
        00010011   十进制 19

        异或 的意思是判断两个相应的位值是否为 异, 是(两个不同)就返1, 否(两个相同)就返0
    
    2) 应用
        (1) 使特定位翻转
            如01111010, 想使其后四位翻转, 即1变为0, 0变为1
                01111010   十进制 122
              ^ 00001111   十进制 15
              -----------
                01110101   十进制 117
            因为15的后四位都为1, 异或将对应位不同的返回1, 相同返回0, 这会使122的后四位变为与原位值相反的, 1变0, 0变1.

        (2) 和0相^, 保留原值
                00001010   十进制 10
              ^ 00000000   十进制 0
              -----------
                000010010  十进制 10
            0所有位都是0, 与其他数对应位比 0^1=1, 0^0=0, 这样返回和原数位上的还是一样的

      ★ (3) 不使用中间量, 交换两个值
            假如 a=3, b=4, 想要将a和b的值互换, 可以如下
                a = a^b;
                b = a^b;
                a = a^b;
            或
                a^=b;
                b^=a;
                a^=b;
            实际发生的
                00000011   a
              ^ 00000100   b
              -----------
                00000111   赋值给 a
              ^ 00000100   b
              -----------
                00000011   赋值给 b
              ^ 00000111   a
              -----------
                00000100   赋值给 a
            a^=b, b^=a; 相当于 b = b^(a^b). 而b^a^b等于a^b^b. b^b^b的结果为0, 因为同一个数和本身相^(异或), 结果必为0, 因此b的值等于a^0, 即a
            之后, a^=b; 由于a的等于a^b, b的值等于b^a^b, 因此, 相当于 a=a^b^b^a^b, 同0^b, 等于b

6. 按位或
    或 | 运算
    两个对应的二进制位中只要有一个为1, 该位的结果值为1
    即: 0|0=0, 0|1=1, 1|0=1, 1|1=1

    1) 例
        00110000   十进制 48
      | 00001111   十进制 15
      -----------
        00111111   十进制 63
    
    2) 应用
        (1) 让一个数的对应位都为1
            如想让一个短整型数的指定位都为1
                00010001   十进制 17
              | 00011000   十进制 24
              -----------
                00011001   十进制 25
            让中间的两位为1
